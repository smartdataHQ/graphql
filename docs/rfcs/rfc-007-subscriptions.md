# Subscriptions

## Problem

Our users would like to use [GraphQL Subscriptions](https://graphql.org/blog/subscriptions-in-graphql-and-relay/) to get real-time updates on their data.

## Requirements

### Must have

- Subscribe to the following events:
  - CREATE
  - UPDATE
  - DELETE
- Ability to filter which nodes are subscribed to (i.e. `where` clause).
- Ability to horizontally scale - either now, or able to do so without breaking in the future.
- Wherever possible, events are ordered.
- Events are fired individually.
- We won't mutate our users' databases - no metadata.
- All events are sent (for example, if node created and then deleted, we get both events).
- Database transactions must be successful - no optimisticness.
- Garbage collection of old subscriptions.
- Some form of auth validation.
- `@neo4j/graphql` should still run on browser

### Should have

- To subscribe to the following events:
  - CONNECT
  - DISCONNECT
- Relationship property updates

### Could have

- Subscriptions to Interface and Union types
- OGM support
- We return "full objects" including nested relationships (for example, a movie subscription must return type `Movie` with nested `actors`)

### Won't have

- Events from changes outside of GraphQL
- Events triggered from custom Cypher
- Support for subscriptions on browser

## Proposed Solution

### Type Definitions
Considering the following definitions:

```graphql
type Movie {
  title: String!
}
```

The subscription type generated by this proposed solution would look like:

```graphql
type Movie {
    title: String!
}


type MovieCreatedEvent {
  event: EventType!
  movieCreated: Movie!
}

type MovieUpdatedEvent {
  event: EventType!
  movieUpdated: Movie!
  previousState: Movie!
}

type MovieDeletedEvent {
  event: EventType!
  movieDeleted: Movie!
}

type Subscription {
  movieCreated(where: MovieWhere): MovieCreatedEvent!
  movieUpdated(where: MovieWhere): MovieUpdatedEvent!
  movieDeleted(where: MovieWhere): MovieDeletedEvent!
}
```

### Usage Examples & Cypher Queries

### Setup
Subscriptions are an opt-in feature, to be activated when passing a subscriptions plugin to the Neo4jGraphQL schema
```typescript
const neoSchema = new Neo4jGraphQL({
    typeDefs,
    driver,
    plugins: {
        subscriptions: new SubscriptionsPlugin(), // e.g. SubscriptionsRedisPlugin()
    },
});
```

#### Subscribing to creation

If a user wanted to subscribe to all movies being created, they could run the following subscription:

```graphql
subscription {
  movieCreated {
    createdMovie {
      title
    }
  }
}
```

Whenever a create operation is executed, metadata regarding the operation will be generated and returned:

```cypher
CALL {
    WITH [] AS meta
    CREATE (this0:Movie)
    SET this0.title = "title"
    WITH meta + { event: "create", id: id(this0), properties: { old: null, new: this0 { .* } }, timestamp: timestamp(), typename: "Movie" } AS meta, this0
    RETURN this0, meta AS this0_meta
}
WITH this0, this0_meta AS meta
RETURN [this0 { .title }] AS data, meta
```

#### Subscribing to update

If a user wants to get the updates of a particular movie, they could use a `where` argument:

```graphql
subscription {
  movieUpdated(where: { title: "Titanic" }) {
    updatedMovie {
      title
    }
    previousState {
        title
    }
  }
}
```

In this case, 2 states are returned, before and after the update.

Whenever a create operation is executed, metadata regarding the operation will be generated and returned:

```cypher
WITH [] AS meta
MATCH (this:Movie)
WHERE this.title = $this_title

WITH this { .* } AS oldProps, this, meta
SET this.title = $this_update_title
WITH this, meta + { event: "update", id: id(this), properties: { old: oldProps, new: this { .* } }, timestamp: timestamp(), typename: "Movie" } AS meta

WITH this, meta
UNWIND meta AS m
RETURN collect(DISTINCT this { .title }) AS data, collect(DISTINCT m) as meta
```

Having the old properties and the new properties to hand means we can actually check whether anything changed as part of the update operation.
Mutations without changes should not trigger update events.

#### Subscribing to delete

If a user wants to get the deletion of a particular movie, they could use a `where` argument:

```graphql
subscription {
  movieDeleted(where: { title: "Titanic" }) {
    deletedMovie {
      title
    }
  }
}
```

Whenever a delete operation is executed, metadata regarding the operation will be generated and returned:

```cypher
WITH [] AS meta
MATCH (this:Movie)
WHERE this.title = $this_title
WITH this, meta + { event: "delete", id: id(this), properties: { old: this { .* }, new: null }, timestamp: timestamp(), typename: "Movie" } AS meta
DETACH DELETE this
WITH meta
UNWIND meta AS m
RETURN collect(DISTINCT m) AS meta
```

#### Subscribe to relationships
To provide support for relationship subscriptions, `connect` and `disconnect` events should be available.

Assuming the following typedefs:
```graphql
type Actor {
    name: String!
    actedIn: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
    title: String!
}
```

##### Connect
If a user wants to subscribe to movies connected to an actor:

```graphql
subscription {
  actorConnected(where: { name: "Keanu" }) {
    actedIn {
      title
    }
  }
}
```

Whenever a create or update operation is executed, metadata regarding the connection events will be created:

```cypher
CALL {
WITH [] AS meta
    CREATE (this0:Actor)
    SET this0.name = $this0_name
    CREATE (this0_actedIn0_node:Movie)
    SET this0_actedIn0_node.title = $this0_actedIn0_node_title
    WITH meta + { event: "create", id: id(this0_actedIn0_node), properties: { old: null, new: this0_actedIn0_node { .* } }, timestamp: timestamp(), typename: "Movie" } AS meta, this0, this0_actedIn0_node
    MERGE (this0)-[r:ACTED_IN]->(this0_actedIn0_node)
    >>>
    WITH meta + { event: "connect", id_from: id(this0), id_to: id(this0_actedIn0_node), id: id(r), properties: {from: this0 {.*}, to: this0_actedIn0_node {.*}, relationship: r {.*}} ,timestamp: timestamp(), relationshipName: "ACTED_IN" }
    <<<
    WITH meta + { event: "create", id: id(this0), properties: { old: null, new: this0 { .* } }, timestamp: timestamp(), typename: "Actor" } AS meta, this0
    RETURN this0, meta AS this0_meta
}
WITH this0, this0_meta AS meta
RETURN [
this0 { .name, actedIn: [ (this0)-[:ACTED_IN]->(this0_actedIn:Movie)   | this0_actedIn { .title } ] }] AS data, meta
```

##### Disconnect
If a user wants to subscribe to movies disconnected from an actor:

```graphql
subscription {
  actorDisconnected(where: { name: "Keanu" }) {
    actedIn {
      title
    }
  }
}
```

Whenever a delete or update operation is executed, metadata regarding the connection events will be created:

```cypher
WITH [] AS meta
MATCH (this:Movie)
WHERE this.title = $this_title
WITH this, meta + { event: "delete", id: id(this), properties: { old: this { .* }, new: null }, timestamp: timestamp(), typename: "Movie" } AS meta
WITH this, meta
OPTIONAL MATCH (this)<-[this_actors0_relationship:ACTED_IN]-(this_actors0:Actor)
WHERE this_actors0.name = $this_deleteMovies.args.delete.actors[0].where.node.name
WITH this, meta, collect(DISTINCT this_actors0) as this_actors0_to_delete
WITH this, this_actors0_to_delete, REDUCE(m=meta, n IN this_actors0_to_delete | m + { event: "delete", id: id(n), properties: { old: n { .* }, new: null }, timestamp: timestamp(), typename: "Actor" }) AS meta
>>>
WITH this, this_actors0_to_delete, REDUCE(m=meta, n IN this_actors0_to_delete | m + { event: "disconnect", id_from: id(this0), id_to: id(n), id: id(this_actors0_relationship), properties: {from: this {.*}, to: n {.*}, relationship: this_actors0_relationship {.*}} ,timestamp: timestamp(), relationshipName: "ACTED_IN" }) AS meta
<<<
FOREACH(x IN this_actors0_to_delete | DETACH DELETE x)
DETACH DELETE this
WITH meta
UNWIND meta AS m
RETURN collect(DISTINCT m) AS meta
```

### Plugin Implementation

Subscriptions will be made available through a plugin, for which we will initially provide a "local" implementation of,
which will not scale horizontally. Providing a plugin API means that later down the line, a plugin can be built which emits
metadata regarding Mutation operations, to be consumed by other instances in a load balanced group.

The plugin will use an `EventEmitter` which is consumed from within each instance. Whenever metadata is returned from a Mutation,
it should be passed to the `publish` function which will handle it appropriately for the implementation.

This plugin definition will look roughly like:

```ts
class Neo4jGraphQLSubscriptionsPlugin {
  public events: EventEmitter;

  constructor() {
    this.events = new EventEmitter();
  }

  abstract public publish(eventMeta: SubscriptionsEvent);
}
```

The "local" implementation of this will look something like:

```ts
class Neo4jGraphQLSubscriptionsLocalPlugin extends Neo4jGraphQLSubscriptionsPlugin {
  public publish(eventMeta: SubscriptionsEvent) {
    this.events.emit(eventMeta);
  }
}
```

And in rough pseudocode, an implementation of this using an AMQP broker would look roughly like:

```ts
class Neo4jGraphQLSubscriptionsAMQPPlugin extends Neo4jGraphQLSubscriptionsPlugin {
  private amqpConnection;

  public publish(eventMeta: SubscriptionsEvent) {
    amqpConnection.publish(eventMeta);
  }

  constructor(brokerUrl, username, password) {
    this.amqpConnection = new AMQPConnection(brokerUrl, username, password);
    this.subscribe();
  }

  private async subscribe() {
    amqpConnection.on("message", (message) => {
      this.events.emit(message);
    })
  }
}
```

#### Alternative interface
Alternatively, the plugin interface exposed to the users could be akin to:

```ts
interface Neo4jGraphQLSubscriptionsPlugin {
    on(eventName: string | symbol, listener: (...args: any[]) => void): this;
    publish(eventMeta: SubscriptionsEvent);
}
```

This would allow for a slightly more flexible interface, not relying on explicit implementations of EventEmitter.

> NOTE: Our current implementation uses the `on()` function from EventEmitter which takes an EventEmitter, that may make this solution hard or not viable.

### Events vs PubSub
Most GraphQL implementations are based on PubSub (e.g. [graphql-subscriptions](https://www.npmjs.com/package/graphql-subscriptions)). However, PubSub
is not a standard, making it hard to provide a library cross-compatible with different servers.

The proposed solution implements an `EventEmitter` and a `publish` method as its interface, this ensures an standard interface that may be used with
PubSub, or any custom solution.

#### PubSub Support
The proposed solution could be used with most PubSub implementations, by subscribing to it and triggering the eventEmitter locally on a custom plugin:

```ts
class MySubscriptionsPlugin extends Neo4jGraphQLSubscriptionsPlugin {
    private pubsub

    constructor(pubsub) {
        super()
        this.pubsub = pubsub
        this.pubsub.subscribe((payload) => {
            this.events.emit(payload.event, payload);
        })

    }

    public publish(eventMeta: SubscriptionsEvent) {
        this.pubsub.publish(eventMeta.event, eventMeta);
    }
}
```

However, due to the hegemony of PubSub, it may be convenient to provide a syntactic sugar support for PubSub. For example:

Provide a custom PubSub Plugin, similar to the example above;
```js
import { PubsubSubscriptipnPlugin } from "@neo4j/graphql-subscriptions"

const subscriptionPlugin = new PubsubSubcriptionPlugin(pubsub)
```

Alternatively, provide native PubSub option on subscription setup:

```typescript
const neoSchema = new Neo4jGraphQL({
    typeDefs,
    driver,
    subscriptions: new PubSub() // Pubsub specification, compatible with graphql-subscriptions
});
```

### Resolvers

A subscription require 2 fields, a `subscribe` method and a `resolver`:
```ts
{
    subscribe: async function *subscribe(where, context) {
        // Filter events
    }
    resolve: async function(payload) {
        // Format and return payload given by subscribe
    },
}

```
### Filtering
Subscriptions can be created with a filter (`where`) statement, this ensures that only subscriptions matching these filters will be triggered.

As an example:
```graphql
subscription SubscribeToMatrix {
  movieCreated(where: {
    title: "The Matrix"
  }) {
    event
    createdMovie {
      title
    }
  }
}
```

This will subscribe to any newly created movie with the title "The Matrix".
The proposed filters should mimic, as possible, the `query` where filters, Including support for:

- `OR`.
- `AND`.
- `_IN`, `_NOT_IN`.
- `_CONTAINS`, `_NOT_CONTAINS`.
- `_STARTS_WITH`, `_ENDS_WITH` and `_NOT` equivalents.
- `_LT`, `_LTE`, `_GT`, `_GTE`.
- `_MATCHES`.

> Due to limitations on filtering, only root level fields can be filtered, aggregations, connections and relationships are out of scope.


#### Update events
Update events, by default, will filter on the previous state, for example, the following subscription:

```graphql
subscription SubscriptionToUpdate {
  movieUpdated(where: {
    title: "The Matrix"
  }) {
    event
  }
}
```
Will be triggered by the mutation:
```graphql
mutation Mutation {
  updateMovies(where: {title: "The Matrix"}, update: {title: "Not a movie"}) {
    movies {
      title
    }
  }
}
```

But not by the subscription:
```graphql
mutation Mutation {
  updateMovies(where: {title: "Cornetto Movie"}, update: {title: "The Matrix"}) {
    movies {
      title
    }
  }
}
```

To support use cases for subscriptions to an updated value, update subscriptions should also provide filters targeting the new value by prepending `NEW`, for instance:

* `NEW_title`.
* `NEW_title_GT`.

This would allow for subscriptions such as:
```graphql
subscription SubscribeToConfirmedUsers {
  userUpdated(where: { AND: [{status: "pending"}, {NEW_status: "confirmed"}] }) {
    name
    status
  }
}
```

### Auth
A new operation `SUBSCRIBE` to deal with authorization on subscriptions, this operation will follow the same syntax and rules as any other operation, but with more
limited scope, allowing only for top-level properties validation (same limitations as `where`).

#### Authentication
```graphql
type Post @auth(rules: [
    { operations: [SUBSCRIBE], isAuthenticated: true }
]) {
    title: String!
}
```

If the user is not authenticated, the subscription request will fail.

#### Allow
Works as usual, but not supported throughout relationships:

```graphql
type User @auth(
    rules: [
        {
            operations: [SUBSCRIBE],
            allow: { id: "$jwt.sub" }
        }
    ]
) {
    id: ID!
    name: String!
}
```

This requires `jwt` to be available in the context on subscription resolver. If a rule does not match, the subscription will not be sent.

#### Bind
Bind does not make sense on subscriptions, as it is intended for mutations. So bind is ignored for SUBSCRIBE operations

#### Roles
Roles should work as usual, the subscription request should error if the role does not match.

#### Where
Where filter in the auth directive should work under the same limitations and behaviour as the subscriptions filtering. With any subscription event not matching
this where not being sent.

### Extra fields in subscription
The following should be available along with the data payload:
- **event**: The event that triggered this event (`CREATE`, `UPDATE`, `DELETE`)
- **timestamp**: The timestamp the event was generated, this may be needed to ensure order consistency on horizontal scaled subscriptions.
- **previousState** (only for updates): State of the node before the modification.


### Nested fields
Due to subscriptions relying on the `meta` data returned by the queries, only top-level properties of the node are available to return or filter.

To properly support nested queries, follow-up queries to the database, after the subscription has been triggered would be required. This may be not viable as each subscription would require an extra request, this not only put a huge load to the database, the subscription itself will take longer to fulfill, instead of close to real-time. Adding some extra metadata and caching subscriptions may help,

Due to this, any nested field queries support should be opt-in.

### Horizontal scalability

#### Problem
While subscriptions may be made to an instance, the mutation triggering the subscriptions may happen on a different instance, the library must support
a broker (e.g. Redis or AMQP).

The plugin implementing eventEmitter is a flexible enough solution as to allow users implementing their own broker to support horizontal scalability, but some well-known providers should be provided by default.

The following list contains an incomplete list of providers that could be supported
- [Redis](https://redis.io/)
- [RabbitMQ](https://www.rabbitmq.com/) & AMQP
- [Kafka](https://kafka.apache.org/)
- [PostgreSQL](https://www.postgresql.org/) (through [pg-ipc](https://www.npmjs.com/package/pg-ipc))
- [Amazon SQS](https://aws.amazon.com/sqs/)
- [Google PubSub](https://cloud.google.com/pubsub)

We should also leverage existing PubSub implementations to these services, some of those deprecated, but well known:
- [graphql-subscriptions](https://github.com/apollographql/graphql-subscriptions)
- [yoga](https://www.graphql-yoga.com/docs/features/subscriptions)

### Subscriptions transports
This library should **not** implement any transport, and should be, when possible, agnostic of how the subscriptions are delivered, as that is part of the server and user implementation. It is important to make sure that the library works as expected with the most common transport methods.

#### Websockets
Most use cases will user WebSockets. The current standard on GraphQL subscriptions delivery through WebSockets is [graphql-ws](https://github.com/enisdenjo/graphql-ws).

While not a high priority, the protocol implemented by [graphql-transport-ws](https://www.npmjs.com/package/graphql-transport-ws) (deprecated) should also work with the library.

#### Server-sent events
An alterantive to websocket are [SSE](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events), with [yoga server](https://www.graphql-yoga.com/docs/features/subscriptions) using them for the subscriptions implementation.

## Security Considerations
The addition of subscriptions creates a new entry top-level access for the database, increasing any security risks. The access to subscriptions should be handled by the `@auth` directive (described above).

Additionally, by the real-time nature of subscriptions, a few extra considerations need to be taken into account:
- **Denial of service attacks**: Real time updates are susceptible to DOS attacks, as any query may trigger a large number of subscriptions.
- **Wss**: We need to ensure that our documentation and library is compatible with WebSocket Secure (WSS).
- Other transports risks: Any new transport (e.g. SSE) may pose new security risks that need to be addressed per case.

> Due to these security considerations, any form of subscriptions must be opt-in for new and existing users.

## Risks

- Maintaining order of events being fired
    - For a single instance this can be guaranteed. On multiple-servers implementations, broker network may lead to unordered events in some cases. The addition of timestamps to the payload would be beneficial in these cases.
- Ensure consistency of events data with data in the database
- Make sure it works across popular PubSub Engine implementations (for example <https://www.apollographql.com/docs/apollo-server/data/subscriptions/#production-pubsub-libraries>)
- Make sure it works with `@auth` directive - users shouldn't be able to listen to events for types they can't access
- Efficiency of Cypher queries - do we fetch all properties of a node and allow GraphQL runtime to filter down, or only the properties in the selection set?

## Discarded solutions

### Solution 1: Subscription field per node type

The subscription type generated by this proposed solution would look like:

```graphql
enum Event {
  CREATE
  UPDATE
  DELETE
}

type MovieEvent {
  event: Event!
  movie: Movie!
}

type Subscription {
  subscribeToMovies(events: [Event!], where: MovieWhere): MovieEvent!
}
```

### Usage Examples

If a user wanted to subscribe to all movies being created, they could run the following subscription:

```graphql
subscription {
  subscribeToMovies(events: [CREATE]) {
    movie {
      title
    }
  }
}
```

If a user wants to get the updates of a particular movie, they could use a `where` argument:

```graphql
subscription {
  subscribeToMovies(events: [UPDATE], where: { title: "Titanic" }) {
    movie {
      title
    }
  }
}
```

For subscribing to multiple events, it would be sensible to query also for the `event` field which could then be used for filtering which event triggered the notification:

```graphql
subscription {
  subscribeToMovies(events: [CREATE, UPDATE]) {
    event
    movie {
      title
    }
  }
}
```

If the `event` argument is not provided, it will be assumed that all events want to be listened for:

```graphql
subscription {
  subscribeToMovies {
    event
    movie {
      title
    }
  }
}
```
